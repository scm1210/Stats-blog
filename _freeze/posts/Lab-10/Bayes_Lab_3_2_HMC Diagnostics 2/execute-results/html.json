{
  "hash": "b26cbd09dbc13d3099e2d8fd866903bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 10.2 (HMC Diagnostics)\"\nsubtitle: \"Pinceton University\"\nauthor: \"Steven Mesquiti\"\noutput: \n  tufte::tufte_html:\n    css: \n    tufte_variant: \"envisioned\"\n    highlight: github-dark\n    fig_height: 10\n    fig_width: 16\n    toc: true\n    toc_depth: 1\nexecute: \n  message: false\n  warning: false\nparams: \n    SHOW_SOLS: TRUE\n    TOGGLE: TRUE\nformat: html\nengine: knitr\ncategories: [Lab, code, analysis]\n---\n\n\n\nThis worksheet helps to give you a better idea about what to do with the trace plots.\n\n## Packages and data\n\nLoad the primary packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pacman)\npacman::p_load(tidyverse, brms, tidybayes,\n               ggdist,bayesplot,moderndive,faux,GGally,ggmcmc,install = T)\nset.seed(42)\n\n\npalette <- c(\n  \"#772e25\", \"#c44536\", \"#ee9b00\", \"#197278\", \"#283d3b\", \n  \"#9CC5A1\", \"#6195C6\", \"#ADA7C9\", \"#4D4861\", \"grey50\",\n  \"#d4a373\", \"#8a5a44\", \"#4a6a74\", \"#5c80a8\", \"#a9c5a0\",\n  \"#7b9b8e\", \"#e1b16a\", \"#a69b7c\", \"#9d94c4\", \"#665c54\"\n)\n\npalette_condition = c(\"#ee9b00\", \"#c44536\",\"#005f73\", \"#283d3b\", \"#9CC5A1\", \"#6195C6\", \"#ADA7C9\", \"#4D4861\")\nplot_aes = theme_minimal() +\n  theme(\n    legend.position = \"top\",\n    legend.text = element_text(size = 12),\n    text = element_text(size = 16, family = \"Futura Medium\"),\n    axis.text = element_text(color = \"black\"),\n    axis.ticks.y = element_blank(),\n    plot.title = element_text(size = 20, hjust = 0.5) # Adjusted title size and centering\n  )\n```\n:::\n\n\n\nThis time we'll simulate data with the **faux** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# how many cases?\nn <- 100\n\n# population values\nmu    <- 0\nsigma <- 1\nrho   <- .5\n\n# simulate and save\nset.seed(1)\n\nd <- rnorm_multi(\n  n = n,\n  mu = c(mu, mu),\n  sd = c(sigma, sigma), \n  r = rho, \n  varnames = list(\"x\", \"y\")\n)\n\nglimpse(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 100\nColumns: 2\n$ x <dbl> -0.232341576, 0.137981847, -0.268214782, 1.302539315, 0.612654423, -…\n$ y <dbl> -0.85270825, 0.18009772, -1.17913643, 1.46056809, -0.04193022, 0.173…\n```\n\n\n:::\n:::\n\n\n\nWe might look at the data with a `ggpairs()` plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  ggpairs(diag = list(continuous = wrap(\"barDiag\", binwidth = 0.25)),\n          upper = list(continuous = wrap(\"cor\", stars = FALSE))) + plot_aes\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nCheck the sample statistics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# univariate\nd %>% \n  pivot_longer(everything()) %>% \n  group_by(name) %>% \n  summarise(m = mean(value),\n            s = sd(value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  name       m     s\n  <chr>  <dbl> <dbl>\n1 x     0.113  0.914\n2 y     0.0754 0.913\n```\n\n\n:::\n\n```{.r .cell-code}\n# bivariate\nd %>% \n  summarise(r = cor(y, x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          r\n1 0.4502206\n```\n\n\n:::\n:::\n\n\n\n## Base model\n\nLet's fit a simple model\n\n$$\n\\begin{align}\ny_i & \\sim \\operatorname{Normal}(\\mu_i, \\sigma) \\\\\n\\mu_i & = \\beta_0 + \\beta_1 x_i \\\\\n\\beta_0 & \\sim \\operatorname{Normal}(0, 1) \\\\\n\\beta_1 & \\sim \\operatorname{Normal}(0, 1) \\\\\n\\sigma & \\sim \\operatorname{Exponential}(1),\n\\end{align}\n$$\n\nAs we fit the model with `brm()`, take the opportunity to consider some of the default settings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_path = '~/Library/CloudStorage/GoogleDrive-sm9518@princeton.edu/My Drive/Classes/Stats-blog/posts/Lab-10/models/fit13b.rds'\n\nif (!file.exists(model_path)) {\n\nfit13.b <- brm(\n  data = d,\n  family = gaussian,\n  y ~ 1 + x,\n  prior = prior(normal(0, 1), class = Intercept) +\n    prior(normal(0, 1), class = b) +\n    prior(exponential(1), class = sigma),\n  seed = 13,\n  \n  # default settings we've been ignoring up to this point\n  iter = 2000, warmup = 1000, chains = 4, cores = 4\n  # if you have a good computer, maybe try setting cores = 4\n)\nsaveRDS(fit13.b,model_path)\n} else {\n  fit13.b <- readRDS(model_path)\n}\n```\n:::\n\n\n\nIf you'd like to use multiple cores, but you're not sure how many you have, execute `parallel::detectCores()`.\n\n#### Question 1: How many cores do you have?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncores = parallel::detectCores()\ncat(\"Steven's computer has:\",cores)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSteven's computer has: 14\n```\n\n\n:::\n:::\n\n\n\n\nCheck the model summary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit13.b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: y ~ 1 + x \n   Data: d (Number of observations: 100) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     0.02      0.08    -0.14     0.18 1.00     3741     3084\nx             0.45      0.09     0.27     0.62 1.00     4125     3260\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.83      0.06     0.72     0.95 1.00     3939     3163\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nLook at the parameter posteriors in a `pairs()` plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npairs(fit13.b, \n      off_diag_args = list(size = 1/3, alpha = 1/3)) \n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nThe `pairs()` plot is a wrapper around the `mcmc_pairs()` function from **bayesplot**. By default, half of the chains are depicted in the scatter plots below the diagonal, and the other half are displayed above the diagonal. The basic idea is you want the results form different chains to mirror one another. You can control this behavior with the `condition` argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npairs(fit13.b, \n      off_diag_args = list(size = 1/3, alpha = 1/3),\n      # here we put the first chain in above the diagonal,\n      # and we put the second through fourth chains below the diagonal\n      condition = pairs_condition(chains = list(1, 2:4)))\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nThis particular arrangement is a little silly, but it should give you a sense of how to control the output. Also, by default the histograms on the diagonal use the draws from all the chains.\n\nIf you wanted, you could also make a similar kind of plot with `ggpairs()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_draws_df(fit13.b) %>% \n  select(b_Intercept:sigma) %>% \n  ggpairs(diag = list(continuous = wrap(\"barDiag\", bins = 25)),\n          upper = list(continuous = wrap(\"cor\", stars = FALSE)),\n          lower = list(continuous = wrap(\"points\", size = 1/4, alpha = 1/3))) + plot_aes\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nNow take a look at the `plot()` output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit13.b, widths = c(1, 2))\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nThese trace plots look like a dream. They have the appearance of fuzzy caterpillars, which is why they're even sometimes called *caterpillar plots*.\n\nLet's work directly with the chains via `as_draws_df()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_draws_df(fit13.b) %>% \n  # notice the 3 meta-data columns at the end\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4,000\nColumns: 9\n$ b_Intercept <dbl> 0.023961191, 0.008764307, -0.066725637, -0.085990390, 0.01…\n$ b_x         <dbl> 0.5574909, 0.5822172, 0.4748096, 0.4267265, 0.4081808, 0.4…\n$ sigma       <dbl> 0.8455813, 0.8642759, 0.7653377, 0.9147409, 0.8412759, 0.7…\n$ Intercept   <dbl> 0.08707099, 0.07467320, -0.01297564, -0.03768355, 0.063654…\n$ lprior      <dbl> -2.842647, -2.874429, -2.716021, -2.844376, -2.764485, -2.…\n$ lp__        <dbl> -124.8296, -125.3474, -125.0186, -126.0295, -124.1495, -13…\n$ .chain      <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ .iteration  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,…\n$ .draw       <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,…\n```\n\n\n:::\n:::\n\n\n\nWe can use those meta-data columns to make our own trace plots with **ggplot** functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_draws_df(fit13.b) %>% \n  pivot_longer(b_Intercept:sigma) %>% \n  mutate(.chain = factor(.chain),\n         # not needed, but makes for Greek formatted strip labels\n         greek = case_when(\n    name == \"b_Intercept\" ~ \"beta[0]\",\n    name == \"b_x\"         ~ \"beta[1]\",\n    name == \"sigma\"       ~ \"sigma\"\n  )) %>% \n  \n  ggplot(aes(x = .iteration, y = value, color = .chain)) +\n  geom_line(linewidth = 1/3) +\n  scale_color_viridis_d(option = \"B\", end = .9) +\n  ggtitle(\"Hand-made trace plots!\") +\n  facet_wrap(~ greek, labeller = label_parsed, scales = \"free_y\") + plot_aes\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nWe might restrict to the first few post-warmup iterations to help give us a better sense of what's happening.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_draws_df(fit13.b) %>% \n  filter(.iteration < 21) %>% \n  pivot_longer(b_Intercept:sigma) %>% \n  mutate(.chain = factor(.chain),\n         # not needed, but makes for nice formatting\n         greek = case_when(\n    name == \"b_Intercept\" ~ \"beta[0]\",\n    name == \"b_x\"         ~ \"beta[1]\",\n    name == \"sigma\"       ~ \"sigma\"\n  )) %>% \n  \n  ggplot(aes(x = .iteration, y = value, color = .chain)) +\n  geom_line(linewidth = 1) +\n  scale_color_viridis_d(option = \"B\", end = .9) +\n  ggtitle(\"Hand-made trace plots (zoomed in)\") +\n  facet_wrap(~ greek, labeller = label_parsed, scales = \"free_y\") + plot_aes\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nNote that these are all post-warmup draws. The **brms** package doesn't make it easy to visualize the warmup draws. But we can do so with a little help from the **ggmcmc** package's `ggs()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first execute without summarise()\nggs(fit13.b) %>% \n  summarise(min = min(Iteration),\n            max = max(Iteration))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n    min   max\n  <int> <int>\n1     1  2000\n```\n\n\n:::\n:::\n\n\n\nNote how how the values in the `Iteration` column range from 1 to 2,000. By **brms** default, the first 1,000 of those iterations are the warmup's. Here is how we can use the `ggs()` output to make trace plots that include the warmup draws.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs(fit13.b) %>% \n  filter(Parameter != \"lprior\") %>% \n  mutate(Chain = factor(Chain),\n         greek = case_when(\n    Parameter == \"b_Intercept\" ~ \"beta[0]\",\n    Parameter == \"b_x\"         ~ \"beta[1]\",\n    Parameter == \"sigma\"       ~ \"sigma\"\n  )) %>% \n  \n  ggplot(aes(x = Iteration, y = value, color = Chain)) +\n  # this marks off the warmups\n  annotate(geom = \"rect\", \n           xmin = 0, xmax = 1000, ymin = -Inf, ymax = Inf,\n           fill = \"black\", alpha = 1/6, linewidth = 0) +\n  geom_line(linewidth = 1/3) +\n  scale_color_viridis_d(option = \"B\", end = .9) +\n  labs(title = \"More hand-made trace plots\",\n       subtitle = \"warmup/post-warmup by background\") +\n  facet_wrap(~ greek, labeller = label_parsed, scales = \"free_y\") + plot_aes\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nLet's take a closer look at the first few warmup iterations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs(fit13.b) %>% \n  filter(Parameter != \"lprior\") %>% \n  mutate(Chain = factor(Chain),\n         greek = case_when(\n    Parameter == \"b_Intercept\" ~ \"beta[0]\",\n    Parameter == \"b_x\"         ~ \"beta[1]\",\n    Parameter == \"sigma\"       ~ \"sigma\"\n  )) %>% \n  \n  ggplot(aes(x = Iteration, y = value, color = Chain)) +\n  annotate(geom = \"rect\", \n           xmin = 0, xmax = 1000, ymin = -Inf, ymax = Inf,\n           fill = \"black\", alpha = 1/6, linewidth = 0) +\n  geom_line(linewidth = 2/3) +\n  scale_color_viridis_d(option = \"B\", end = .9) +\n  coord_cartesian(xlim = c(0, 50)) +\n  labs(title = \"More hand-made trace plots (zoomed in)\",\n       subtitle = \"warmup only\") +\n  facet_wrap(~ greek, labeller = label_parsed, scales = \"free_y\") + plot_aes\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n#### Question 2: Can you use the results here to describe the need for discarding warmup draws?\n\nThe warmup draws are not representative of the posterior distribution. The warmup draws are used to help the HMC algorithm find a good starting point for the post-warmup draws. The post-warmup draws are what we use to make inferences about the posterior distribution.\n\nAnother issue is *autocorrelation*, the degree to which a given HMC draw is correlated with the previous draw(s). We can make a plot of the autocorrelations with the `mcmc_acf()` function from the **bayesplot** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit13.b %>% \n  mcmc_acf(pars = vars(b_Intercept, b_x, sigma),\n           lags = 10)  # lags = 20 is the default\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nThis is what we like to see: Nice L-shaped autocorrelation plots. Low autocorrelations like this are one of the major achievements of Stan's implementation of HMC. It's not uncommon for MCMC via the older Gibbs sampler method to routinely show much higher autocorrelations. You can get a sense of this by comparing the various models in Kruschke's (2015) textbook, which often uses the Gibbs sampler, versus their `brms()` analogues in my (2023) ebook translation.\n\n::: callout-note\nMixing describes how efficiently MCMC chains explore the posterior distribution. Good mixing means samples move freely across the parameter space. And high autocorrelation =\\> poor mixing.\n:::\n\n#### Question 3: Why are L-shaped autocorrelation plots are desirable? What would an undesirable autocorrelation plot look like?\n\nL-shaped autocorrelation plots are desirable because they indicate that the MCMC chains are mixing well and exploring the parameter space efficiently. In contrast, an undesirable autocorrelation plot would show high autocorrelations at many lags, indicating that the samples are highly correlated and not effectively exploring the posterior distribution.\n\nThose low autocorrelations also have a lot to do with our effective sample size (ESS) estimates. Take another look at the `summary()` output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit13.b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: y ~ 1 + x \n   Data: d (Number of observations: 100) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     0.02      0.08    -0.14     0.18 1.00     3741     3084\nx             0.45      0.09     0.27     0.62 1.00     4125     3260\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.83      0.06     0.72     0.95 1.00     3939     3163\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nThere used to be a single ESS column. Starting with version 2.10.0, **brms** returns two columns: `Bulk_ESS` and `Tail_ESS`. These originate from Vehtari et al (2019). From the paper, we read:\n\n> When reporting quantile estimates or posterior intervals, we strongly suggest assessing the convergence of the chains for these quantiles. In Section 4.3, we show that convergence of Markov chains is not uniform across the parameter space, that is, convergence might be different in the bulk of the distribution (e.g., for the mean or median) than in the tails (e.g., for extreme quantiles). We propose diagnostics and effective sample sizes specifically for extreme quantiles. This is different from the standard ESS estimate (which we refer to as bulk-ESS), which mainly assesses how well the centre of the distribution is resolved. Instead, these \"tail-ESS\" measures allow the user to estimate the MCSE for interval estimates. (pp. 672-673)\n\nWe generally like the values in both the `Bulk_ESS` and `Tail_ESS` columns to be as close to the total number of post-warmup draws as possible, which would be 4,000 for a default `brm()` model. Sometimes, as in the case of the `Bulk_ESS` value for our $\\beta_1$ parameter, the HMC chains are so efficient that we can get larger numbers than the actual number of post-warmup draws. This is related to when we have negative autocorrelations (see above).\n\nHow much is enough, and how low is too low? Yeah, indeed... Higher is generally better, with diminishing returns rolling in somewhere between 1,000 and 10,000. **brms** will give you a warning message when the ESS estimates get below a couple hundred.\n\nNow look back at the `Rhat` column in the `summary()` output. This is the potential scale reduction factor $\\hat R$. It has its origins in Gelman & Rubin (1992), but the current version used in **brms** is from Vehtari et al (2019), as cited above. In short, it is something of a ratio of the between-chain variation versus the within-chain variation. This ratio is usually a little above 1, and we want it to be as close to 1 as possible. The Stan team (e.g., <https://mc-stan.org/rstan/reference/Rhat.html)> recommends against values greater than 1.05. In our case, we're good to go.\n\n## What bad chains look like..\n\nNow let's break the model. This time, we'll subset the `d` data to just the first 2 rows, we'll make the priors very wide on the scale of the data, and we'll dramatically reduce the `warmup` period.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_path = '~/Library/CloudStorage/GoogleDrive-sm9518@princeton.edu/My Drive/Classes/Stats-blog/posts/Lab-10/models/fit14b.rds'\n\nif (!file.exists(model_path)) {\n\nfit14.b <- brm(\n  data = d %>% slice(1:2),\n  family = gaussian,\n  y ~ 1 + x,\n  # don't use priors like this for real data analyses\n  prior = prior(normal(0, 100000), class = Intercept) +\n    prior(normal(0, 100000), class = b) +\n    prior(uniform(0, 100000), class = sigma),\n  seed = 14,\n  iter = 1100, warmup = 100, chains = 4, cores = 10\n)\n\nsaveRDS(fit14.b,model_path)\n} else {\n  fit14.b <- readRDS(model_path)\n}\n```\n:::\n\n\n\nCheck the parameter summary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(fit14.b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: y ~ 1 + x \n   Data: d %>% slice(1:2) (Number of observations: 2) \n  Draws: 4 chains, each with iter = 1100; warmup = 100; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept   478.83   2036.34 -1979.74  6652.81 1.46        8       13\nx         -1228.64   3124.10 -6776.94  5668.31 1.88        6       15\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma  6231.76  11923.16   165.35 42287.98 1.13       22      336\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nNever ignore Warning messages like that.\n\nThose `Rhat`, `Bulk_ESS`, and `Tail_ESS` look really bad. Also notice how large the posterior means (`Estimate`) and standard deviations (`Est.Error`) are. Seems off, eh?\n\nLet's investigate further with a `pairs()` plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit14.b, widths = c(1, 2))\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nThis is a full-scale disaster. DO NOT trust model results from chains that look like this.\n\nIn this case, just giving the model a longer `warmup` period helped a lot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_path = '~/Library/CloudStorage/GoogleDrive-sm9518@princeton.edu/My Drive/Classes/Stats-blog/posts/Lab-10/models/fit15b.rds'\n\nif (!file.exists(model_path)) {\n\nfit15.b <- brm(\n  data = d %>% slice(1:2),\n  family = gaussian,\n  y ~ 1 + x,\n  # don't use priors like this in real life\n  prior = prior(normal(0, 100000), class = Intercept) +\n    prior(normal(0, 100000), class = b) +\n    prior(uniform(0, 100000), class = sigma),\n  seed = 14,\n  iter = 2000, warmup = 1000, chains = 4, cores = 10\n)\n\nsaveRDS(fit15.b,model_path)\n} else {\n  fit15.b <- readRDS(model_path)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit15.b, widths = c(1, 2))\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nWe still have a lot of Warning messages, but things have improved.\n\nWe can do an even better with default weakly-regularizing priors.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_path = '~/Library/CloudStorage/GoogleDrive-sm9518@princeton.edu/My Drive/Classes/Stats-blog/posts/Lab-10/models/fit16b.rds'\n\nif (!file.exists(model_path)) {\n\nfit16.b <- brm(\n  data = d %>% slice(1:2),\n  family = gaussian,\n  y ~ 1 + x,\n  prior = prior(normal(0, 1), class = Intercept) +\n    prior(normal(0, 1), class = b) +\n    prior(exponential(1), class = sigma),\n  seed = 14,\n  iter = 2000, warmup = 1000, chains = 4, cores = 4\n)\n\nsaveRDS(fit16.b,model_path)\n} else {\n  fit16.b <- readRDS(model_path)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit16.b, widths = c(1, 2))\n```\n\n::: {.cell-output-display}\n![](Bayes_Lab_3_2_HMC-Diagnostics_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nNow look at the parameter summaries.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(fit16.b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: y ~ 1 + x \n   Data: d %>% slice(1:2) (Number of observations: 2) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept    -0.23      0.49    -1.21     0.83 1.00     1810     1643\nx             0.47      0.99    -1.46     2.38 1.00     1955     1932\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.86      0.59     0.19     2.45 1.00     1065      982\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nThose Warning messages still remain, but they're less dire than before. Also, most of the other diagnostics look better. I still wouldn't trust this model. It is only based on 2 data points, after all. But look how far we got by paying attention to the diagnostics and picking better priors.\n\n## References\n\nGelman, A. and Rubin, D. (1992). Inference from iterative simulation using multiple sequences. *Statistical Science, 7*(4):457–472. <https://dx.doi.org/10.1214/ss/1177011136>\n\nKruschke, J. K. (2015). *Doing Bayesian data analysis: A tutorial with R, JAGS, and Stan*. Academic Press. <https://sites.google.com/site/doingbayesiandataanalysis/>\n\nKurz, A. S. (2023). *Doing Bayesian data analysis in brms and the tidyverse* (Version 1.1.0). <https://bookdown.org/content/3686/>\n\nMcElreath, R. (2020). *Statistical rethinking: A Bayesian course with examples in R and Stan* (Second Edition). CRC Press. <https://xcelab.net/rm/statistical-rethinking/>\n\nVehtari, A., Gelman, A., Simpson, D., Carpenter, B., & Bürkner, P.-C. (2019). Rank-normalization, folding, and localization: An improved $\\widehat R$ for assessing convergence of MCMC (with discussion). *Bayesian Analysis, 16*(2), 667-718. <https://doi.org/10.1214/20-BA1221>\n\n## Session information\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS 15.4\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] ggmcmc_1.5.1.1   GGally_2.2.1     faux_1.2.2       moderndive_0.7.0\n [5] bayesplot_1.11.1 ggdist_3.3.2     tidybayes_3.0.7  brms_2.21.0     \n [9] Rcpp_1.0.13      lubridate_1.9.3  forcats_1.0.0    stringr_1.5.1   \n[13] dplyr_1.1.4      purrr_1.0.4      readr_2.1.5      tidyr_1.3.1     \n[17] tibble_3.2.1     ggplot2_3.5.1    tidyverse_2.0.0  pacman_0.5.1    \n\nloaded via a namespace (and not attached):\n  [1] infer_1.0.7          RColorBrewer_1.1-3   tensorA_0.36.2.1    \n  [4] rstudioapi_0.17.1    jsonlite_1.8.9       magrittr_2.0.3      \n  [7] estimability_1.5.1   farver_2.1.2         nloptr_2.1.1        \n [10] rmarkdown_2.28       vctrs_0.6.5          minqa_1.2.8         \n [13] base64enc_0.1-3      janitor_2.2.1        htmltools_0.5.8.1   \n [16] distributional_0.5.0 curl_5.2.2           broom_1.0.7         \n [19] StanHeaders_2.32.10  htmlwidgets_1.6.4    plyr_1.8.9          \n [22] emmeans_1.10.7       zoo_1.8-12           igraph_2.0.3        \n [25] mime_0.12            lifecycle_1.0.4      pkgconfig_2.0.3     \n [28] colourpicker_1.3.0   Matrix_1.7-0         R6_2.5.1            \n [31] fastmap_1.2.0        rbibutils_2.3        shiny_1.9.1         \n [34] snakecase_0.11.1     digest_0.6.37        colorspace_2.1-1    \n [37] crosstalk_1.2.1      labeling_0.4.3       fansi_1.0.6         \n [40] timechange_0.3.0     abind_1.4-5          compiler_4.4.1      \n [43] withr_3.0.1          backports_1.5.0      inline_0.3.19       \n [46] shinystan_2.6.0      ggstats_0.9.0        QuickJSR_1.3.1      \n [49] pkgbuild_1.4.4       MASS_7.3-60.2        gtools_3.9.5        \n [52] loo_2.8.0            tools_4.4.1          httpuv_1.6.15       \n [55] threejs_0.3.3        glue_1.8.0           nlme_3.1-164        \n [58] promises_1.3.0       grid_4.4.1           checkmate_2.3.2     \n [61] reshape2_1.4.4       generics_0.1.3       operator.tools_1.6.3\n [64] gtable_0.3.5         tzdb_0.4.0           formula.tools_1.7.1 \n [67] hms_1.1.3            utf8_1.2.4           pillar_1.9.0        \n [70] markdown_1.13        posterior_1.6.0      later_1.3.2         \n [73] splines_4.4.1        lattice_0.22-6       survival_3.6-4      \n [76] tidyselect_1.2.1     miniUI_0.1.1.1       knitr_1.48          \n [79] reformulas_0.4.0     arrayhelpers_1.1-0   gridExtra_2.3       \n [82] V8_6.0.1             stats4_4.4.1         xfun_0.52           \n [85] rstanarm_2.32.1      bridgesampling_1.1-2 matrixStats_1.4.1   \n [88] DT_0.33              rstan_2.32.6         stringi_1.8.4       \n [91] yaml_2.3.10          boot_1.3-30          evaluate_1.0.0      \n [94] codetools_0.2-20     cli_3.6.4            RcppParallel_5.1.9  \n [97] shinythemes_1.2.0    xtable_1.8-4         Rdpack_2.6.2        \n[100] munsell_0.5.1        coda_0.19-4.1        svUnit_1.0.6        \n[103] parallel_4.4.1       rstantools_2.4.0     dygraphs_1.1.1.6    \n[106] Brobdingnag_1.2-9    lme4_1.1-36          viridisLite_0.4.2   \n[109] mvtnorm_1.3-1        scales_1.3.0         xts_0.14.1          \n[112] rlang_1.1.5          shinyjs_2.1.0       \n```\n\n\n:::\n:::\n",
    "supporting": [
      "Bayes_Lab_3_2_HMC-Diagnostics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}